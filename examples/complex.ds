// complex.sp - demo avanzado corregido (versión robusta)
interface Person {
  name::str;
  age::num;
  tags::arr[];
  meta::obj;
}
// variables y tipos
let username::str = "Manuel";
let score::num = 42;
const MAX_SCORE::num = 100;
let flags::arr = [true, false, maybe];
let cfg::obj = { debug: true, version: "0.1" };
let trust::mbool = maybe;
// reasignaciones y mut/inmut
username = "Manuel R.";
mut score = 50;
inmut username; // convierte a const a partir de aquí

// array / objeto
flags = [false, true, maybe];
cfg = { debug: false, files: ["a","b"] };

// funciones y call
func Greet(person::str) {
  spec.log("Hola " + person + "!");
  return "greeted " + person;
}

func Sum(a::num, b::num) {
  return a + b;
}

// usar
Greet(username);
spec.log("Suma:", Sum(3,4));

// clase con inicializador + métodos
class Counter {
  constructor(initial::num) {
    this.count = initial;
  }
  inc() {
    this.count = this.count + 1;
  }
  add(n::num) {
    this.count = this.count + n;
  }
}

const c = new Counter(2);
c.inc();
c.add(5);
spec.log("Counter:", c.count);

// bucles
let i::num = 0;
for (i = 0; i < 3; i = i + 1) {
  spec.log("for i:", i);
}

let w::num = 0;
while (w < 2) {
  spec.log("while w:", w);
  w = w + 1;
}

// if / elif / else (usamos if/else-if)
let opt::str = "B";
if (opt === "A") {
  spec.log("Option A");
} else if (opt === "B") {
  spec.log("Option B");
} else {
  spec.log("Default");
}

// try/catch/finally
try {
  if (score > MAX_SCORE) {
    throw new Error("Score too big");
  }
} catch (err) {
  spec.log("Error capturado:", err.message);
} finally {
  spec.log("Finally runs");
}

// uso de interfaces (meta)
let p::obj = { name: "Luisa", age: 21, tags: ["dev","student"], meta: { verified: true } };

